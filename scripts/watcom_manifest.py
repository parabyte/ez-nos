#!/usr/bin/env python3
"""
Extract the object-to-source manifest from the legacy Borland makefile.

The Watcom build script uses this helper to figure out which translation
units should be compiled. The original tree stored several generations
of the source (root, ALTERED, ORIGINAL); we prefer the root copy when it
exists, fall back to ALTERED, then ORIGINAL.
"""

from __future__ import annotations

import argparse
import sys
from pathlib import Path
from typing import Iterable, List, Sequence, Tuple


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Generate a Watcom-friendly build manifest based on ALTERED/MAKEFILE/MAKEFILE",
    )
    parser.add_argument(
        "--makefile",
        default="ALTERED/MAKEFILE/MAKEFILE",
        help="Path to the legacy makefile that holds the mkdep section",
    )
    parser.add_argument(
        "--output",
        required=True,
        help="File that will receive lines in the form 'object.obj|/abs/path/to/source.c'",
    )
    parser.add_argument(
        "--root",
        default=".",
        help="Project root used to resolve default search directories",
    )
    parser.add_argument(
        "--extra-search",
        action="append",
        default=[],
        metavar="PATH",
        help="Additional directories (recursively scanned) that may contain sources",
    )
    return parser.parse_args()


def iter_sources(base: Path, recursive: bool) -> Iterable[Path]:
    if not base.exists():
        return
    if recursive:
        iterator = base.rglob("*")
    else:
        iterator = base.glob("*")
    for candidate in iterator:
        if not candidate.is_file():
            continue
        if candidate.suffix.lower() != ".c":
            continue
        yield candidate.resolve()


def build_search_plan(root: Path, extras: Sequence[str]) -> List[Tuple[Path, bool]]:
    plan: List[Tuple[Path, bool]] = [
        (root, False),  # prefer files stored at the project root
        (root / "ALTERED", True),
        (root / "ORIGINAL", True),
    ]
    for extra in extras:
        plan.append((Path(extra).expanduser().resolve(), True))
    return plan


def build_file_map(plan: Sequence[Tuple[Path, bool]]) -> dict[str, Path]:
    file_map: dict[str, Path] = {}
    for directory, recursive in plan:
        for source in iter_sources(directory, recursive):
            key = source.name.lower()
            # Do not overwrite an entry that was found in a directory with higher priority.
            file_map.setdefault(key, source)
    return file_map


def parse_mkdep_section(makefile: Path) -> List[Tuple[str, str]]:
    entries: List[Tuple[str, str]] = []
    contents = makefile.read_text(errors="ignore").splitlines()
    section = False
    marker = "# this section generated by mkdep".lower()
    for raw_line in contents:
        line = raw_line.strip()
        if not section:
            if line.lower().startswith(marker):
                section = True
            continue
        if not line or line.startswith("#") or ":" not in line:
            continue
        target, deps = line.split(":", 1)
        target = target.strip()
        if not target.lower().endswith(".obj"):
            continue
        first = deps.strip().split()[0]
        entries.append((target, first))
    return entries


def main() -> int:
    args = parse_args()
    root = Path(args.root).expanduser().resolve()
    makefile = Path(args.makefile).expanduser().resolve()
    if not makefile.exists():
        print(f"error: makefile '{makefile}' does not exist", file=sys.stderr)
        return 2

    plan = build_search_plan(root, args.extra_search)
    file_map = build_file_map(plan)
    entries = parse_mkdep_section(makefile)
    try:
        mk_display = makefile.relative_to(root)
    except ValueError:
        mk_display = makefile

    missing: List[str] = []
    manifest_lines: List[str] = []
    for obj, src in entries:
        key = Path(src).name.lower()
        resolved = file_map.get(key)
        if resolved is None:
            missing.append(src)
            continue
        manifest_lines.append(f"{obj}|{resolved}")

    if missing:
        header = f"error: {len(missing)} source file(s) referenced by {mk_display} are missing:"
        print("\n".join([header] + [f"  - {name}" for name in missing]), file=sys.stderr)
        print(
            "Make sure the complete EZNOS source archive is unpacked before running the Watcom build.",
            file=sys.stderr,
        )
        return 1

    output_path = Path(args.output).expanduser().resolve()
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(manifest_lines) + "\n")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
